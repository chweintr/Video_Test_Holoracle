<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Transitions (Clean Stage)</title>
    <link href="https://fonts.googleapis.com/css2?family=Michroma&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet" />
    <style>
      *,*::before,*::after{box-sizing:border-box}
      html,body{height:100%}
      body{margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

      :root{
        /* base anchors for assets/new-back.png */
        --target-left: 37.66%;
        --target-top: 24.86%;
        --target-size: 24.53%;
        --mount-center-x: calc(var(--target-left) + var(--target-size)/2);
        --title-up: 14.91cqh;    /* 161/1080 */
        --subtitle-up: 9.35cqh;  /* 101/1080 */
        --buttons-gap: 16.0cqh;  /* lower buttons more */
        --select-gap: 24.0cqh;   /* raised slightly per feedback */
        --title-size: 3.8cqh;    /* larger title */
        --subtitle-size: 1.3cqh; /* smaller to leave room for strap lines */
        /* Feather control - reliable floating effect for ALL personas */
        --mask-inner: 85%;  /* solid center radius */
        --mask-outer: 99%;  /* gentle fade-out for floating effect */
        --overlay-opacity: 0.6; /* default overlay strength */
      }

      .stage{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100vw,calc(100svh*16/9));aspect-ratio:16/9;overflow:hidden;}
      .parallax-layer{position:absolute;inset:0;background:radial-gradient(circle at var(--mx,50%) var(--my,50%), rgba(77,227,255,0.15), transparent 40%);mix-blend-mode:screen;pointer-events:none;z-index:1}
      .stage>img.bg{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;object-position:center}

      .mount{position:absolute;left:var(--target-left);top:var(--target-top);width:var(--target-size);aspect-ratio:1/1;outline:2px solid rgba(0,200,255,.7);overflow:hidden;z-index:2}
      .mount video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;pointer-events:none}

      /* Widget layer (positioning context) */
      .widget-layer { position: absolute; inset: 0; z-index: 5; }

      /* MINIMAL STYLING - just try to theme the button without breaking colors */
      simli-widget::part(button),
      simli-widget button {
        background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(77,227,255,0.4)) !important;
        border: 2px solid rgba(0,255,255,0.6) !important;
        color: #00ffff !important;
        font-family: 'Courier New', monospace !important;
        text-transform: uppercase !important;
        border-radius: 6px !important;
      }
      
      /* FEATHERING CLASS - apply mask when widget is active */
      simli-widget.feathered {
        -webkit-mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 70%, rgba(0,0,0,0) 95%) !important;
        mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 70%, rgba(0,0,0,0) 95%) !important;
        overflow: hidden !important;
      }
      
      /* FILL MOUNT LIKE PARTICLES VIDEO - 100% fill with object-fit */
      .widget-layer simli-widget {
        position: absolute !important;
        inset: 0 !important;
        width: 100% !important;
        height: 100% !important;
        object-fit: cover !important;  /* KEY: same as particles video */
        
        /* CENTER THE TRIGGER BUTTON */
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
      
      /* Try to position trigger button in center */
      .widget-layer simli-widget button,
      .widget-layer simli-widget [role="button"],
      .widget-layer simli-widget .trigger {
        position: absolute !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        z-index: 100 !important;
      }
      
      /* FEATHERING ON WIDGET LAYER - not individual widget */
      .widget-layer {
        -webkit-mask-image: radial-gradient(circle at 50% 50%, black 70%, transparent 100%) !important;
        mask-image: radial-gradient(circle at 50% 50%, black 70%, transparent 100%) !important;
      }

      /* Overlays must never block the trigger */
      .overlay-loop, .overlay-transition { 
        pointer-events: none !important; 
      }

      /* Optional feathering - ONLY after widget is active */
      .widget-layer.simli-active simli-widget {
        -webkit-mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 85%, rgba(0,0,0,0) 98%);
        mask-image: radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 85%, rgba(0,0,0,0) 98%);
        overflow: hidden !important;
      }
      
      /* Ensure overlays never block clicks */
      .overlay-loop, .overlay-transition { pointer-events: none !important; }

      /* REMOVED: No scaling - conflicts with transform: none */
      
      /* Remove duplicate CSS - handled by JS */
      
      /* Try to reach inner surfaces (if Simli exposes parts) */
      simli-widget::part(container),
      simli-widget::part(surface),
      simli-widget::part(video),
      simli-widget::part(canvas) {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover !important;
        background: transparent !important;
        border-radius: 0 !important;
      }
      
      /* REMOVED: Conflicting CSS that was forcing display:flex and overriding absolute positioning */
      
      /* Removed transform scaling to avoid interfering with widget init */
      
      /* Loading message styling */
      .loading-message {
        position: absolute;
        left: var(--mount-center-x);
        top: calc(var(--target-top) + (var(--target-size) * (16/9)) + 3cqh);
        transform: translateX(-50%);
        color: #ffff00;
        font-family: 'Courier New', monospace;
        font-size: 2.0cqh;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        text-shadow: 0 0 10px #ffff00;
        z-index: 8;
        animation: pulse 1.5s ease-in-out infinite;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
      }
      .ui{position:absolute;inset:0;pointer-events:none;z-index:3}
      .title{position:absolute;left:var(--mount-center-x);top:calc(var(--target-top) - var(--title-up) - 1.0cqh);transform:translateX(-50%);text-align:center;max-width:60cqw;white-space:nowrap;font-weight:700;font-family:'Michroma','Courier New',monospace;letter-spacing:.08em;text-transform:uppercase;font-size:var(--title-size);line-height:1.05;color:#00ffff;text-shadow:0 0 20px #00ffff,0 0 40px #7e6bff}
      .subtitle{position:absolute;left:var(--mount-center-x);top:calc(var(--target-top) - var(--subtitle-up));transform:translateX(-50%);text-align:center;max-width:calc(var(--target-size)*1.25);font-size:var(--subtitle-size);line-height:1.05;color:#ff4df3;letter-spacing:.15em;text-transform:uppercase;text-shadow:0 0 10px #ff4df3}
      .strap{position:absolute;left:var(--mount-center-x);transform:translateX(-50%);text-align:center;font-family:'Courier New',monospace;letter-spacing:.10em;text-transform:uppercase;color:rgba(255,255,255,.80);font-size:1.2cqh;text-shadow:0 0 8px rgba(255,255,255,.35)}
      .strap.s1{top:calc(var(--target-top) - var(--subtitle-up) + 2.4cqh)}
      .strap.s2{top:calc(var(--target-top) - var(--subtitle-up) + 4.2cqh)}
      .persona{position:absolute;left:var(--mount-center-x);top:calc(var(--target-top) + var(--target-size)*(16/9) + var(--buttons-gap));transform:translateX(-50%);display:flex;gap:1.2cqw;pointer-events:auto}
      .persona button{background:linear-gradient(135deg,rgba(0,0,0,.6),rgba(77,227,255,.1));border:2px solid rgba(77,227,255,.5);color:#00ffff;padding:.9cqh 1.8cqw;font-size:1.9cqh;font-family:'Courier New', monospace;text-transform:uppercase;letter-spacing:.03em;border-radius:6px;cursor:pointer}
      .persona button:hover{border-color:#00ffff;box-shadow:0 0 20px rgba(0,255,255,.4);transform:translateY(-2px)}
      .select{position:absolute;left:var(--mount-center-x);top:calc(var(--target-top) + var(--target-size)*(16/9) + var(--select-gap));transform:translateX(-50%);font-size:2.0cqh;color:rgba(0,255,255,.85);text-shadow:0 0 10px rgba(0,255,255,.85)}

      /* Visual overlays inside mount */
      .overlay-loop{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;pointer-events:none;z-index:6;display:none;opacity:var(--overlay-opacity,0.6)}
      .overlay-transition{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;pointer-events:none;z-index:7;display:none}
    </style>
  </head>
  <body>
    <div class="stage">
      <img class="bg" src="assets/new-back.png?v=pitch-ready" alt="Background" />
      <div class="parallax-layer" id="parallaxLayer"></div>
      <div class="mount">
        <video class="base" autoplay loop muted playsinline>
          <source src="assets/social_okdonut_Thick_volumetric_smoke_plumes_and_millions_of_micro_p_4123dadd-5c4c-412d-aa5a-49b4e72a7929_2.mp4" type="video/mp4" />
        </video>
        <div class="widget-layer" id="widgetLayer">
          <div class="widget-host" id="widgetHost"></div>
        </div>
        <!-- Optional alpha overlay (loop). WebM with alpha preferred; MP4 fallback is visually additive only. -->
        <video class="overlay-loop" id="overlayLoop" autoplay loop muted playsinline>
          <source src="assets/cube_generation.webm?v=1" type="video/webm" />
          <source src="assets/Cube_generation.mov?v=1" type="video/quicktime" />
        </video>
        <!-- Persona transition (one-shot) shown on persona select, then hides -->
        <video class="overlay-transition" id="overlayTransition" muted playsinline></video>
      </div>
      <div class="ui">
        <div class="title">Echoes of Indiana</div>
        <div class="subtitle">Holographic Conversations Powered by Research</div>
        <div class="strap s1">Compelled by Curiosity</div>
        <div class="strap s2">Brought to you by Past Presence</div>
        <div class="persona">
          <button data-persona="bigfoot">Brown County Bigfoot</button>
          <button data-persona="indiana">Hoosier Oracle</button>
          <button data-persona="vonnegut">Kurt Vonnegut</button>
          <button data-persona="larrybird">Larry Bird</button>
        </div>
        <div class="select" id="selectText">Select Oracle</div>
        <button id="endSession" style="display:none; position:absolute; top:20px; right:20px; background:red; color:white; padding:10px; cursor:pointer; z-index:10; pointer-events:auto;">End Session</button>
      </div>
    </div>
    
    <!-- Simli Widget Script -->
    <script src="https://app.simli.com/simli-widget/index.js" async></script>
    
     <script>
      console.log('Transitions build v2025-08-14: feather ON (85/99), overlay loop ON (essential), thinking messages ON');
      
      // EMERGENCY: Aggressively clear Daily.co conflicts that break Simli video
      try {
        // Clear all Daily-related globals
        ['DailyIframe', 'Daily', 'DailyCall', 'CallManager'].forEach(name => {
          if (window[name]) {
            console.log(`[DEBUG] Clearing ${name}`);
            delete window[name];
          }
        });
        
        // Clear any existing iframes that might be Daily
        document.querySelectorAll('iframe').forEach(iframe => {
          if (iframe.src && iframe.src.includes('daily')) {
            console.log('[DEBUG] Removing Daily iframe');
            iframe.remove();
          }
        });
      } catch (e) {
        console.log('[DEBUG] Daily cleanup error (probably fine):', e);
      }
      // Configuration from main_kiosk.html
      const CONFIG = {
        personas: {
          bigfoot: {
            name: 'Brown County Bigfoot',
            agentId: '4a857f92-feee-4b70-b973-290baec4d545',
            enhanced: false
          },
          indiana: {
            name: 'Hoosier Oracle',
            agentId: 'cd04320d-987b-4e26-ba7f-ba4f75701ebd',
            faceId: 'd21a631c-28f8-4220-8da3-ea89bc4e5487',
            enhanced: false
          },
          vonnegut: {
            name: 'Kurt Vonnegut',
            agentId: '2970497b-880f-46bb-b5bf-3203dc196db1',
            faceId: 'fde520ba-106d-4529-91b2-fecb04da5257',
            enhanced: true
          },
          larrybird: {
            name: 'Larry Bird',
            agentId: '126ac401-aaf7-46c3-80ec-02b89e781f25',
            faceId: '1b0eef6f-2650-49ce-a7cd-296d1af0e339',
            enhanced: true
          }
        }
      };
      
      let currentWidget = null;
      let currentPersona = null;
      
      // SMART DAILY CLEANUP - clean instances but preserve library for Simli
      async function forceCleanupDaily() {
        console.log('[Smart] Starting Daily.co cleanup');
        
        // Remove any leftover Daily iframes first
        const iframes = document.querySelectorAll('iframe');
        console.log(`[Smart] Checking ${iframes.length} iframes`);
        iframes.forEach(iframe => {
          if (iframe.src && (iframe.src.includes('daily.co') || iframe.src.includes('daily') || iframe.className.includes('daily'))) {
            console.log('[Smart] Removing Daily iframe:', iframe.src || iframe.className);
            iframe.remove();
          }
        });
        
        // Clear call-related globals but KEEP Daily library for Simli
        ['DailyIframe', 'DailyCall', 'CallManager'].forEach(name => {
          if (window[name]) {
            console.log(`[Smart] Clearing ${name}`);
            delete window[name];
          }
        });
        
        // DON'T delete window.Daily - Simli needs it!
        console.log('[Smart] Daily.co cleanup complete (preserved Daily library)');
      }
      
      // Wire up persona buttons with proper cleanup delay
      document.querySelectorAll('.persona button').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const personaId = e.target.dataset.persona;
          if (!personaId) return;
          
          // CRITICAL: End current session first and wait for cleanup
          if (currentWidget) {
            console.log('[Switch] Cleaning up previous widget before switch');
            await endCurrentSession();
            // Wait for proper cleanup to prevent Daily conflicts
            await new Promise(resolve => setTimeout(resolve, 1500));
          }
          
          await switchPersona(personaId);
        });
      });
      
      // End session button
      document.getElementById('endSession').addEventListener('click', async () => {
        await endCurrentSession();
      });
      
      async function switchPersona(personaId) {
        console.log(`[Transitions] Switching to: ${personaId}`);
        
        // CRITICAL: Smart Daily cleanup BEFORE any new widget
        await forceCleanupDaily();
        
        // Brief wait for cleanup to complete  
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Hide select text
        document.getElementById('selectText').style.display = 'none';
        
        // End current session if active
        if (currentWidget) {
          await endCurrentSession();
        }
        
        currentPersona = personaId;
        // Feather only: apply gentle global values (no persona variance)
        document.documentElement.style.setProperty('--mask-inner', '85%');
        document.documentElement.style.setProperty('--mask-outer', '99%');
        document.documentElement.style.setProperty('--overlay-opacity', '0.6');
        const persona = CONFIG.personas[personaId];
        
        if (!persona) {
          console.error(`Unknown persona: ${personaId}`);
          return;
        }

        // Show base video to verify mount alignment before widget loads
        const baseVideo2 = document.querySelector('video.base');
        if (baseVideo2) baseVideo2.style.display = 'block';
        
        // Show thinking message after 3s delay (simulates post-summon timing)
        setTimeout(() => {
          if (currentPersona === personaId) { // Only show if still same persona
            showLoadingMessage(personaId);
          }
        }, 3000);
        
        try {
          // Get token from backend
          const response = await fetch(`${window.location.origin}/simli-token?agentId=${persona.agentId}`);
          const data = await response.json();
          
          if (!data.token) {
            throw new Error('No token received');
          }
          
          console.log(`[Transitions] Got token for ${personaId}`);
          
          // Create widget in mount
          await createSimliWidget(personaId, data.token, persona.agentId, persona.faceId);
          
          // Keep loading message visible; it will auto-hide or be cleared by widget events
          
        } catch (error) {
          console.error(`[Transitions] Error for ${personaId}:`, error);
          hideLoadingMessage();
          alert(`Failed to load ${persona.name}`);
        }
      }
      
      async function createSimliWidget(personaId, token, agentId, faceId) {
        // Hide base video
        const baseVideo = document.querySelector('video.base');
        if (baseVideo) {
          baseVideo.style.display = 'none';
        }
        
        // Use GPT-5's minimal attach function
        attachSimliWidget({ token, agentId, faceId });
        
        // Show end session button
        document.getElementById('endSession').style.display = 'block';
        
        console.log(`[Transitions] Widget created for ${personaId}`);
      }
      
      // EMERGENCY FIX: Put widget OUTSIDE mount completely until it works
      function attachSimliWidget({ token, agentId, faceId }) {
        const stage = document.querySelector('.stage');
        
        // Remove any existing widgets
        const existing = stage.querySelector('simli-widget');
        if (existing) existing.remove();
        
        const w = document.createElement('simli-widget');
        w.setAttribute('token', token);
        w.setAttribute('agentid', agentId);
        if (faceId) w.setAttribute('faceid', faceId);
        
        // GENTLE CUSTOMIZATION: Only safe attributes that don't break connection
        w.setAttribute('customtext', 'Summon');  // Change button text to "Summon"
        
        // Remove potentially problematic attributes
        w.removeAttribute('customimage');
        w.removeAttribute('hidetrigger');
        w.removeAttribute('autostart');
        
        // NO INLINE STYLES - let CSS handle everything like particles video
        // Widget will fill mount automatically via CSS rules
        
        // Add to widget layer IN MOUNT (not stage)
        const widgetLayer = document.getElementById('widgetLayer');
        widgetLayer.appendChild(w);
        console.log('[Stage 1] Widget added to mount widget-layer - should fill like particles video');
        
        // STAGE 2: Detect activation and apply constraints (ONLY after user clicks trigger)
        let userHasClicked = false;
        
        // Listen for clicks on the widget to know when user activates it
        w.addEventListener('click', () => {
          userHasClicked = true;
          console.log('[Stage 1.5] User clicked trigger - waiting for activation');
        });
        
        const detectActivation = setInterval(() => {
          // Only check for video AFTER user has clicked the trigger
          if (!userHasClicked) return;
          
          // Look for video element (indicates widget is active)
          const hasVideo = w.shadowRoot?.querySelector('video') || w.querySelector('video');
          if (hasVideo) {
            clearInterval(detectActivation);
            console.log('[Stage 2] Widget activated - SKIPPING manipulation to prevent call disconnect');
            
            // COMMENTED OUT - THIS WAS KILLING THE CONNECTION!
            // // Move to mount and apply exact sizing
            // const mount = document.querySelector('.mount');
            // mount.appendChild(w);
            // 
            // // Apply mount constraints
            // w.style.cssText = `
            //   position: absolute !important;
            //   inset: 0 !important;
            //   width: 100% !important;
            //   height: 100% !important;
            //   background: transparent !important;
            //   border: none !important;
            //   object-fit: cover !important;
            // `;
            // 
            // // Enable feathering
            // w.style.setProperty('-webkit-mask-image', 'radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 85%, rgba(0,0,0,0) 98%)', 'important');
            // w.style.setProperty('mask-image', 'radial-gradient(circle at 50% 50%, rgba(0,0,0,1) 85%, rgba(0,0,0,0) 98%)', 'important');
            // 
            // // Show overlay video
            // const overlayLoop = document.getElementById('overlayLoop');
            // if (overlayLoop) {
            //   overlayLoop.style.display = 'block';
            //   overlayLoop.style.opacity = '0.6';
            //   try { overlayLoop.play().catch(() => {}); } catch(e) {}
            // }
            
            console.log('[Stage 2] Widget left untouched - connection should stay active');
            
            // TRY CAREFULLY: Add overlay WITHOUT touching widget DOM
            const overlayLoop = document.getElementById('overlayLoop');
            if (overlayLoop) {
              console.log('[Overlay] Attempting to show overlay without breaking connection');
              overlayLoop.style.display = 'block';
              overlayLoop.style.opacity = '0.6';
              overlayLoop.style.pointerEvents = 'none';
              try { overlayLoop.play().catch(() => {}); } catch(e) {}
            }
            
            // TRY CAREFULLY: Apply feathering with CSS class instead of direct manipulation
            setTimeout(() => {
              console.log('[Feather] Attempting to add feather class');
              w.classList.add('feathered');
            }, 500);
            
            // FORCE VIDEO TO START - fix the 0x0 video issue
            setTimeout(() => {
              console.log('[DEBUG] Widget final state:');
              console.log('- Position:', w.style.position);
              console.log('- Size:', w.offsetWidth + 'x' + w.offsetHeight);
              console.log('- Video element:', w.shadowRoot?.querySelector('video') || 'not found');
              console.log('- Parent:', w.parentElement?.className || 'none');
              
              if (w.shadowRoot?.querySelector('video')) {
                const video = w.shadowRoot.querySelector('video');
                console.log('- Video playing:', !video.paused);
                console.log('- Video dimensions:', video.videoWidth + 'x' + video.videoHeight);
                
                // FORCE VIDEO START if it's not playing
                if (video.paused || video.videoWidth === 0) {
                  console.log('[FIX] Forcing video to start...');
                  video.muted = true; // Ensure autoplay works
                  video.setAttribute('autoplay', '');
                  video.setAttribute('playsinline', '');
                  
                  // Multiple attempts to start video
                  const startVideo = async () => {
                    try {
                      await video.play();
                      console.log('[FIX] Video started successfully');
                      
                      // Double-check after a moment
                      setTimeout(() => {
                        if (video.videoWidth > 0) {
                          console.log('[FIX] Video confirmed playing:', video.videoWidth + 'x' + video.videoHeight);
                        } else {
                          console.log('[FIX] Video still 0x0, trying user interaction');
                          // Add click handler to try again on user interaction
                          w.addEventListener('click', () => {
                            video.play().catch(e => console.log('[FIX] Click retry failed:', e));
                          }, { once: true });
                        }
                      }, 1000);
                      
                    } catch (e) {
                      console.log('[FIX] Video start failed:', e);
                      // Try clicking the widget again
                      setTimeout(() => {
                        w.click();
                        console.log('[FIX] Clicked widget to retry activation');
                      }, 1000);
                    }
                  };
                  
                  startVideo();
                }
              }
            }, 2000);
          }
        }, 200);
        
        // Clear detection after 30 seconds
        setTimeout(() => clearInterval(detectActivation), 30000);
        
        currentWidget = w; // Store reference for cleanup
      }

      // Overlay setup: re-enable alpha overlay (non-negotiable for floating head effect)
      (function(){
        const loopVid = document.getElementById('overlayLoop');
        if (!loopVid) return;
        const show = () => {
          loopVid.style.display = 'block';
          loopVid.style.mixBlendMode = 'screen';
          try { loopVid.play().catch(()=>{}); } catch(_){}
        };
        const hide = () => { loopVid.style.display = 'none'; };
        loopVid.addEventListener('canplay', show, { once: true });
        loopVid.addEventListener('error', hide, { once: true });
      })();

      // Persona transition overlay (GIF/MP4/WebM). Pointer-events: none so it never blocks Simli.
      function playTransitionOverlay(personaId){
        const el = document.getElementById('overlayTransition');
        if (!el) return;
        const map = {
          bigfoot: { src: 'assets/particles-to-bigfoot.gif', durationMs: 1800 },
          indiana: { src: 'assets/particles-to-indiana.gif', durationMs: 1800 },
          vonnegut: { src: 'assets/particles-to-vonnegut.gif', durationMs: 1800 },
          larrybird: { src: 'assets/particles-to-larry.gif', durationMs: 1800 }
        };
        const cfg = map[personaId];
        if (!cfg) { el.style.display = 'none'; el.src = ''; return; }
        
        // Show full-scale transition overlay
        el.style.display = 'block';
        el.style.zIndex = '10'; // Above widget layer during transition
        el.src = cfg.src; // GIF will autoplay visually when shown
        
        // Hide after duration to reveal widget underneath
        const t = window.setTimeout(()=>{ 
          el.style.display = 'none'; 
          el.style.zIndex = '7'; // Reset z-index
          el.removeAttribute('src'); 
        }, cfg.durationMs || 1500);
        el.onended = () => { 
          window.clearTimeout(t); 
          el.style.display = 'none'; 
          el.style.zIndex = '7'; // Reset z-index
          el.removeAttribute('src'); 
        };
        try { el.play && el.play().catch(()=>{}); } catch(_){}
      }
      
      // Loading message functions
      function showLoadingMessage(personaId) {
        const messages = {
          bigfoot: ['Bigfoot is coming to his senses...', 'Bigfoot is brushing off the fog...'],
          indiana: ['The Oracle is aligning the stars...', 'Hoosier wisdom is syncing in…'],
          vonnegut: ['Kurt is calibrating consciousness...', 'Kurt is collecting his thoughts…'],
          larrybird: ['Larry is lacing up...', 'Larry is scanning the court...']
        };
        
        const personaMessages = messages[personaId] || ['Hold tight… a presence is forming...', 'Injecting brains… please stand by...'];
        const randomMessage = personaMessages[Math.floor(Math.random() * personaMessages.length)];
        
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'loadingMessage';
        loadingDiv.className = 'loading-message';
        loadingDiv.textContent = randomMessage;
        
        // Remove any existing loading message
        hideLoadingMessage();
        
        // Add to UI layer
        document.querySelector('.ui').appendChild(loadingDiv);
        // Extended auto-hide after ~8s so messages linger longer on screen
        window.clearTimeout(window.__loadingHideT);
        window.__loadingHideT = window.setTimeout(hideLoadingMessage, 8000);
      }
      
      function hideLoadingMessage() {
        const existing = document.getElementById('loadingMessage');
        if (existing) {
          existing.remove();
        }
      }
      
      // Dismissal message functions
      function showDismissalMessage(personaId) {
        const messages = {
          bigfoot: ['Bigfoot is shambling back to his conspiracy cave...', 'Bigfoot is returning to photoshop...'],
          indiana: ['The Oracle is dissolving into corn dust...', 'The Oracle is returning to the limestone...'],
          vonnegut: ['Kurt is becoming unstuck in time...', 'Kurt is ice-nining out of here...'],
          larrybird: ['Larry is heading to the bench...', 'Larry is taking his talents to French Lick...']
        };
        
        const personaMessages = messages[personaId] || ['The presence fades away...', 'Returning to the void...'];
        const randomMessage = personaMessages[Math.floor(Math.random() * personaMessages.length)];
        
        const dismissDiv = document.createElement('div');
        dismissDiv.id = 'dismissalMessage';
        dismissDiv.className = 'loading-message';
        dismissDiv.textContent = randomMessage;
        dismissDiv.style.color = '#ff6b6b'; // Different color for dismissal
        
        // Remove any existing messages
        hideLoadingMessage();
        const existing = document.getElementById('dismissalMessage');
        if (existing) existing.remove();
        
        // Add to UI layer
        document.querySelector('.ui').appendChild(dismissDiv);
        // Auto-hide after 2s
        setTimeout(() => {
          if (dismissDiv && dismissDiv.parentNode) {
            dismissDiv.remove();
          }
        }, 2000);
      }
      
      async function endCurrentSession() {
        console.log('[Cleanup] Starting enhanced session cleanup');
        
        // Show dismissal message
        if (currentPersona) {
          showDismissalMessage(currentPersona);
        }
        
        // NUCLEAR: Force Daily cleanup first
        await forceCleanupDaily();
        
        // PROPER WIDGET CLEANUP - prevent Daily iframe conflicts
        if (currentWidget) {
          try {
            console.log('[Cleanup] Destroying widget properly');
            // Try Simli's cleanup methods if they exist
            if (typeof currentWidget.destroy === 'function') {
              currentWidget.destroy();
              console.log('[Cleanup] Called widget.destroy()');
            }
            if (typeof currentWidget.disconnect === 'function') {
              currentWidget.disconnect();
              console.log('[Cleanup] Called widget.disconnect()');
            }
            // Remove from DOM
            if (currentWidget.parentNode) {
              currentWidget.parentNode.removeChild(currentWidget);
            }
          } catch (e) {
            console.log('[Cleanup] Widget cleanup error (continuing):', e);
          }
        }
        
        // Clear widget layer and remove active state
        const layer = document.getElementById('widgetLayer');
        if (layer) {
          layer.classList.remove('simli-active');
          layer.innerHTML = '';
        }
        
        // Clear any widgets from stage too
        const stage = document.querySelector('.stage');
        stage.querySelectorAll('simli-widget').forEach(w => w.remove());
        
        currentWidget = null;
        
        // Show base video again
        const baseVideo = document.querySelector('video.base');
        if (baseVideo) {
          baseVideo.style.display = 'block';
        }
        
        // Hide end session button
        document.getElementById('endSession').style.display = 'none';
        hideLoadingMessage();
        
        // Hide any loading message
        hideLoadingMessage();
        
        // Show select text
        document.getElementById('selectText').style.display = 'block';
        
        currentPersona = null;
        console.log('[Transitions] Session ended');
      }
      
      // Parallax mouse effect (subtle), desktop only
      (function(){
        const layer = document.getElementById('parallaxLayer');
        if (!layer) return;
        let mx = 50, my = 50, ticking = false;
        function update(){
          layer.style.setProperty('--mx', mx + '%');
          layer.style.setProperty('--my', my + '%');
          ticking = false;
        }
        window.addEventListener('mousemove', (e) => {
          mx = (e.clientX / window.innerWidth) * 100;
          my = (e.clientY / window.innerHeight) * 100;
          if (!ticking){ requestAnimationFrame(update); ticking = true; }
        }, {passive:true});
      })();
    </script>
  </body>
  </html>


